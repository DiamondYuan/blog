---
title: JavaScript 高级程序设计读书笔记 第 4 章 变量、作用域和内存问题
date: 2019-3-24 13:43:00
tags:
  - JavaScript
  - JavaScript 高级程序设计
categories:
  - 读书笔记
thumbnail: https://blog-staticfile.diamondyuan.com/2019-08-26-code.jpg
---

# 第 4 章 变量、作用域和内存问题

## 4.1 基本类型和引用类型

ECMAScript 变量可能包含两种不同数据类型的：基本类型值和引用类型值。基本类型值指的是简单的数据段,而引用类型值指那些可能由多个值构成的对象。
在将一个值赋绐变量时,解析器必须确定这个值是基本类型值还是引用类型值。基本类型是按值访问的，引用类型是按引用访问的。

<!-- more -->

### 4.1.1 动态的属性

对于引用类型的值,我们可以为其添加属性和方法,也可以改变和删除其属性和方法。而我们不能给基本类型的值添加属性，尽管不会导致任何错误。

### 4.1.2 复制变量值

如果从一个变量向另外一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配得位置上。
当从一个变量向另一个变量复制引用类型的值时,同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是,这个值的副本实际上是一个指针,而这个指针指向存储在堆中的一个对象。复制操作结束后,两个变量实际上将引用同一个对象。

### 4.1.3 传递参数

ECMAScript 中所有函数的参数都是按值传递的。把函数外部的值复制给函数内部的参数,就和把值从一个变量复制到另一个变量一样。在向参数传递引用类型的值时,会把这个值在内存中的地址复制给一个局部变量。所以局部变量的变化会反映在外部。

### 4.1.4 检测类型

检测一个变量是不是基本数据类型，可以使用 `typeof`，如果想知道某个值是什么类型的对象，可以使用 `instanceof` 操作符。
如果变量是给定引用类型的实例，那么 `instanceof` 操作符会返回 true 。

## 4.2 执行环境及作用域

每一个执行环境都有与之关联的`变量对象`，环境中定义的所有变量和函数都保存在这个对象中。
全局执行环境是最外围的一个执行环境，根据 ECMA 所在的宿主环境不同，执行环境对象也不一样。浏览器中，全局执行环境被认为是 window 对象。
每个函数都有自己的执行环境，当执行流进入一个函数时，函数环境就会被推入环境栈中。函数执行后，栈将其环境退出。把控制器交还给之前的执行环境。
当代码在环境中执行，会创建`变量对象`的一个作用域链。作用域链的用处是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，永远都是当前执行代码所在环境的`变量对象`。
如果这个环境是函数,则将其`活动对象`作为`变量对象`。活动对象在最开始时只包含一个变量，即 arguments 对象，作用域链中的下一个`变量对象`来自包含(外部)环境，而再下一个`变量对象`则来自下一个包含环境。这样,一直延续到全局执行环境。全局执行环境的`变量对象`始终都是作用域链中的最后一个对象。

内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。每个环节都可以向上搜索作用域链，以查询变量和函数名。

### 4.2.1 延长作用域链

With 不常用，略。
4.2.2 var 没有块级作用域

```js
if (true) {
  var color = "blue";
}
console.log(color); //blue
```

使用 var 声明的变量会添加到最接近的环境中

```js
for (var i = 0; i < 10; i++) {
  //doSomething
}
console.log(i); //10
```

如果在循环中创建变量，在循环结束后依旧会存在于循环的外部执行环境中。

1. 声明变量
   使用 var 声明的变量会添加到最接近的环境中，如果初始化变量时候没有声明，则会被添加到全局环境（严格模式会报错）。
2. 查询标识符
   当环境中为了读取或写入而引入一个标识符时，会从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境找到该标识符，搜索结果停止。一直追溯到全局环境的变量对象。

## 4.3 垃圾收集 GC

### 4.3.1 标记清除

略

### 4.3.2 引用计数

略

## 4.4 小结

JavaScript 变量可以保存两种类型的值，基本类型和引用类型。基本类型和引用类型有以下特点。

- 基本类型在内存中占据固定大小的空间，因此被保存在栈内存中；
- 从一个变量向另一个变量复制基本类型的值，会创建这个值的副本；
- 引用类型的值是对象,保存在堆内存中;
- 包含引用类型值的变量实际上包含的并不是对象本身,而是一个指向该对象的指针;
- 从一个变量向另一个变量复制引用类型的值,复制的其实是指针,因此两个变量最终都指向同一个对象;
- 确定一个值是哪种基木类型可以使用 typeof 操作符,而确定一个值是哪种引用类型可以使用 instanceof 操作符。

所有变量(包括基本类型和引用类型)都存在于一个执行环境(也称为作用域)当中,这个执行环境决定了变量的生命周期,以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结

- 执行环境有全局执行环境(也称为全局环境)和函数执行环境之分;
- 每次进入一个新执行环境,都会创建一个用于搜索变量和函数的作用域链;
- 函数的局部环境不仅有权访问函数作用域中的变量,而且有权访问其包含(父)环境,乃至全局环境;
- 全局环境只能访问在全局环境中定义的变量和函数,而不能直接访问局部环境中的任何数据;
- 变量的执行环境有助于确定应该何时释放内存。
  Javascript 是一门具有自动垃圾收集机制的编程语言,开发人员不必关心内存分配和回收问题。可以对 JavaScript 的垃圾收集例程作如下总结。
- 离开作用域的值将被自动标记为可以回收,因此将在垃圾收集期间被删除。
- “标记清除”是目前主流的垃圾收集算法,这种算法的思想是给当前不使用的值加上标记,然后再回收其内存。
- 另一种垃圾收集算法是“引用计数”,这种算法的思想是跟踪记录所有值被引用的次数。 JavaScript 引擎目前都不再使用这种算法;但在 IE 中访问非原生 JavaScript 对象(如 DOM 元素)时,这种算法仍然可能会导致问题。
- 当代码中存在循环引用现象时,“引用计数”算法就会导致问题。
- 解除变量的引用不仅有助于消除循环引用现象,而且对垃圾收集也有好处。为了确保有效地回收内存,应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。
